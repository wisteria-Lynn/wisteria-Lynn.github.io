{"meta":{"title":"流莹离的个人博客","subtitle":"流莹离的个人博客","description":"流莹离的个人博客","author":"流莹离","url":"http://yoursite.com"},"pages":[{"title":"流莹离的玲珑居","date":"2019-10-15T06:53:52.000Z","updated":"2019-10-16T00:51:47.910Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"小说QQ群：658343145"}],"posts":[{"title":"节流和防抖","slug":"js知识/节流和防抖","date":"2019-11-07T00:41:52.000Z","updated":"2019-11-07T01:01:13.415Z","comments":true,"path":"2019/11/07/js知识/节流和防抖/","link":"","permalink":"http://yoursite.com/2019/11/07/js知识/节流和防抖/","excerpt":"","text":"节流 throttle(译音：sralte)防抖 debounce(译音：dibeiaos)简化： 1234567891011121314function debounce(fn,delay)&#123; let timer = null return (...args)=&gt;&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(this,args) &#125;,delay) &#125;&#125;function domClick()&#123; debounce((args)=&gt;&#123; console.log(args) &#125;,2000)&#125; 按钮点击节流12345678910111213141516/** * 按钮 点击节流 */export const stopClick = function (name,callBack,time=1000,msg=`请等待1s后再次点击`)&#123; return new Promise((resolve,reject)=&gt;&#123; if(name)&#123; console.log(`$&#123;msg&#125; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;`) return false &#125; callBack(true) setTimeout(()=&gt;&#123; callBack(false) &#125;,time) resolve() &#125;)&#125;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"css的一些常见面试题","slug":"css/css的一些常见面试题","date":"2019-11-06T07:19:18.000Z","updated":"2019-11-06T08:57:45.361Z","comments":true,"path":"2019/11/06/css/css的一些常见面试题/","link":"","permalink":"http://yoursite.com/2019/11/06/css/css的一些常见面试题/","excerpt":"","text":"flex布局flex:Flexible Box(弹性布局) 为盒状模型提供最大的灵活性，任何一个容器都可以指定为Flex布局。 Webkit内核的浏览器，必须加上-webkit前缀。/*safari*/ 12345&lt;div class=\"box\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 123.box&#123; display:flex;&#125; 在父元素设置，水平主轴，垂直交叉轴 flex-direction:row|row-reverse|column|column-reverse(决定主轴方向：水平左端|水平右端|垂直上沿|垂直下沿) flex-wrap:nowrap|wrap|wrap-reverse;(轴线排不下，如何换行:默认不换行|换行，第一行在上方|换行，第一行在下方) flex-flow:row nowrap;(是前两者的简写) justify-content:flex-start|flex-end|center|space-between|space-around;(主轴对齐方式：左对齐|右对齐|居中|两端对齐|间隔对齐) align-item:flex-start|flex-end|center|baseline|stretch;(交叉轴如何对齐：上对齐|下对齐|居中|第一行文字的基线对齐|默认沾满容器) align-content:flex-start|flex-end|center|space-between|space-around|stretch;(多跟轴线的对齐方式，只有一根轴线，属性无效。) 子元素设置 order:0;(子元素排列顺序。数值越小，排列越靠前) flex-grow:0;(子元素放大比例) flex-shrink:0;(子元素缩小比例) 子元素的float,clear,vertical-align属性失效 css3新特性 transtion 过渡效果。 transition-property:none | all | [ &lt;IDENT&gt; ];(指定元素的执行属性:无|所有属性|指定元素属性) transition-duration ： time;(默认为0，元素转换过程的持续时间,单位为s或ms) transition-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier;(根据时间的推进去改变属性值的变换速率:逐渐变慢，默认|均速|加速|减速|加速然后减速|自定义特制的贝赛尔曲线) transition-delay:time;(一个动画延迟执行的时间：默认为0) 1234/*多个属性过度，逗号隔开*/.box&#123; transition:background 0.5s ease-in,color 0.3s ease-out;&#125; transition-property可指定的元素属性如下： 123456789101112131415161718192021222324251、color: 通过红、绿、蓝和透明度组件变换（每个数值处理）如：background-color,border-color,color,outline-color等css属性；2、length: 真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,padding,outline-width,margin,min-width,min-height,max-width,max-height,line-height,height,border-width,border-spacing,background-position等属性；3、percentage:真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,min-width,min-height,max-width,max-height,line-height,height,background-position等属性；4、integer离散步骤（整个数字），在真实的数字空间，以及使用floor()转换为整数时发生 如：outline-offset,z-index等属性；5、number真实的（浮点型）数值，如：zoom,opacity,font-weight,等属性；6、transform list:详情请参阅：《CSS3 Transform》7、rectangle:通过x, y, width 和 height（转为数值）变换，如：crop8、visibility: 离散步骤，在0到1数字范围之内，0表示“隐藏”，1表示完全“显示”,如：visibility9、shadow: 作用于color, x, y 和 blur（模糊）属性,如：text-shadow10、gradient: 通过每次停止时的位置和颜色进行变化。它们必须有相同的类型（放射状的或是线性的）和相同的停止数值以便执行动画,如：background-image11、paint server (SVG): 只支持下面的情况：从gradient到gradient以及color到color，然后工作与上面类似12、space-separated list of above:如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化13、a shorthand property: 如果缩写的所有部分都可以实现动画，则会像所有单个属性变化一样变化 ainimation实现动画效果 translate 3D建模效果 img中alt和title的区别 图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化 图片中的 title属性是在鼠标在移动到元素上的文本提示。 css创建三角形12345678div&#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000;&#125; 原理：css的border边框是对线分割，当元素有高宽时是梯形，没有高宽时是三角形。 css的盒子模型 标准盒子：width = content + border +padding IE怪异盒模型：width = content div水平居中 margin:auto; position:absolute;translate(-50%,0) div增加一个父元素，父元素使用display:flex;justify-content:center; div垂直水平居中 使用position,translate属性。 div增加一个父元素，父元素使用display:flex;justify-content:center;align-item:center; 图片垂直居中 增加一个父元素，父元素使用display:flex;align-item:center; 增加一个祖父元素display:table，增加一个父元素display:table-cell;vertical-align:middle; 清除浮动浮动的影响：脱离文档流，造成父元素的塌陷。 clear:both;在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;} after伪类 1234567891011float_div:after&#123;content:\".\";clear:both;display:block;height:0;overflow:hidden;visibility:hidden;&#125;.float_div&#123; zoom:1&#125; 三栏布局，左右固定，中间自适应 圣杯布局/双飞翼布局 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;head&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .middle, .left, .right &#123; position: relative; float: left; min-height: 130px; &#125; .container &#123; padding: 0 220px 0 200px; overflow: hidden; &#125; .left &#123; margin-left: -100%; left: -200px; width: 200px; background: red; &#125; .right &#123; margin-left: -220px; right: -220px; width: 220px; background: green; &#125; .middle &#123; width: 100%; background: blue; word-break: break-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='container'&gt; &lt;div class='middle'&gt;&lt;/div&gt; &lt;div class='left'&gt;&lt;/div&gt; &lt;div class='right'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; display:none 和 visibility: hidden的区别 display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 CSS中 link 和@import 的区别是？ link属于HTML标签，而@import是CSS提供的 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import只在IE5以上才能识别，而link是HTML标签，无兼容问题 渲染：!import &gt; 内联 &gt; style标签 &gt; @import &gt; link","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[],"keywords":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}]},{"title":"file,blob,base64格式转换","slug":"js知识/file-blob-base64格式转换","date":"2019-10-30T00:55:08.000Z","updated":"2019-11-05T08:15:01.716Z","comments":true,"path":"2019/10/30/js知识/file-blob-base64格式转换/","link":"","permalink":"http://yoursite.com/2019/10/30/js知识/file-blob-base64格式转换/","excerpt":"","text":"File通常情况下， File 对象是来自用户在一个 &lt;input&gt;元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。 File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context中。 构造函数 123456var myFile = new File(bits, name[, options]);// 例如var file = new File([\"foo\"], \"foo.txt\", &#123; type: \"text/plain\",&#125;);Object.prototype.toString.call(file)// [object File] 参数： bitsArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。 name USVString，表示文件名称，或者文件路径。 options(可选) 选项对象，包含文件的可选属性。可用的选项如下： type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 “” 。 lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。 属性 File 接口也继承了 Blob 接口的属性： File.lastModified 只读返回当前 File 对象所引用文件最后修改时间，自 UNIX 时间起始值（1970年1月1日 00:00:00 UTC）以来的毫秒数。 File.lastModifiedDate 只读返回当前 File 对象所引用文件最后修改时间的 Date 对象。 File.name 只读返回当前 File 对象所引用文件的名字。 File.size 只读返回文件的大小。 File.webkitRelativePath 只读返回 File 相关的 path 或 URL。 File.type 只读返回文件的 多用途互联网邮件扩展类型（MIME Type） 方法 File 接口没有定义任何方法，但是它从 Blob 接口继承了以下方法： Blob.slice([start[, end[, contentType]]])返回一个新的 Blob 对象，它包含有源 Blob 对象中指定范围内的数据。 file可分blob碎片提交 浏览器兼容 Edge/IE 不支持File的构造函数 File转url1234let _URL = window.URL || window.webkitURL;let url = _URL.createObjectURL(file|blob)// 释放_URL.revokeObjectURL(url) base64转Blob12345678function dataURLtoBlob(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125; Blob转为base6412345function blobToDataURL(blob, callback) &#123; let a = new FileReader(); a.onload = function (e) &#123; callback(e.target.result); &#125; a.readAsDataURL(blob);&#125; base64转File12345678function dataURLtoFile(dataurl, filename) &#123;//将base64转换为文件 var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123;type:mime&#125;); &#125; url转base64123456789101112131415function getImgToBase64(url,callback)&#123;//将图片转换为Base64 var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), img = new Image; img.crossOrigin = 'Anonymous'; img.onload = function()&#123; canvas.height = img.height; canvas.width = img.width; ctx.drawImage(img,0,0); var dataURL = canvas.toDataURL('image/png'); callback(dataURL); canvas = null; &#125;; img.src = url;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"arguments","slug":"js知识/arguments","date":"2019-10-29T01:11:55.000Z","updated":"2019-11-06T06:12:37.240Z","comments":true,"path":"2019/10/29/js知识/arguments/","link":"","permalink":"http://yoursite.com/2019/10/29/js知识/arguments/","excerpt":"","text":"arguments 是一个对应于传递给函数的参数的类数组对象。 语法 arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 1234567// 列如：function func(a,b,c)&#123; console.log(arguments[0])// a console.log(arguments[1])// [1,2] console.log(arguments[2])// ()=&gt;&#123;&#125;&#125;func('a',[1,2],()=&gt;&#123;&#125;) arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array： 123456var args = Array.prototype.slice.call(arguments);var args = [].slice.call(arguments);// ES2015const args = Array.from(arguments);const args = [...arguments]; 类型 123456789// 只能在函数内部使用console.log(typeof arguments) // undefined function test(a)&#123; console.log(a,Object.prototype.toString.call(arguments)); // 1,'object','[object Arguments]' console.log(arguments[0],arguments[1]);// 1 undefined console.log(typeof arguments[0]);// number&#125;test(1);","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"ES6新特性","slug":"js知识/ES6新特性","date":"2019-10-28T00:46:43.000Z","updated":"2019-10-29T01:24:34.377Z","comments":true,"path":"2019/10/28/js知识/ES6新特性/","link":"","permalink":"http://yoursite.com/2019/10/28/js知识/ES6新特性/","excerpt":"","text":"let,const let let定义变量不可以再次定义,可以从新赋值 具有块级作用域 没有变量提升,必须先定义在使用 let声明的变量不能被window调用,是独立的 const const定义常量,是不可变的,一旦定义,不能修改其值 初始化常量时,必须给初始值 具有块级作用域 没有变量提升,必须先定义在使用 const声明的常量也是独立的,不能被window调用 var变量提升，可被window调用，可以不给初始值，具有全局作用域 解构赋值 数组解构 1234// 1.变量和值一一对应let arr = [1, 2, 3];let [a, b, c] = arr;console.log(a,b,c); // 1 2 3 1234// 2. 变量多,值少let arr = [1, 5, 8];let [a, b, c, d] = arr;console.log(a, b, c, d); // 1 5 8 undefined 1234// 3. 变量少,值多let arr = [5, 9, 10, 8, 3, 2];let [a, b] = arr;console.log(a, b); // 5, 9 1234// 4.按需取值let arr = [5, 9, 10, 8, 3, 2];let [, , a, , b] = arr; // 不需要用变量接收的值，用空位占位console.log(a, b); // 10, 3 12345678// 5.剩余值let arr = [5, 9, 10, 8, 3, 2];let [a, b, ...c] = arr; // ...c 接收剩余的其他值，得到的c是一个数组console.log(a, b, c); // 结果：// a = 5, // b = 9, // c = [10, 8, 3, 2] 1234// 6.复杂的情况,只要符合模式.即可解构let arr = ['zhangsan', 18, ['175cm', '65kg']];let [, , [a, b]] = arr;console.log(a, b); // 175cm 65kg 对象解构 123456// 1. 变量名和属性名一样let &#123; foo, bar &#125; = &#123;foo: 'aaa', bar: 'bbb'&#125;;console.log(foo, bar); // aaa, bbblet &#123;a, c&#125; = &#123;a: 'hello', b: 'world'&#125;;console.log(a, c); // hello, undefined 123// 2. 通过 :来更改变量名let &#123;a, b:c&#125; = &#123;a: 'hello', b: 'world'&#125;;console.log(a, c); // hello, world 1234// 3. 变量名和属性名一致即可获取到值,不需要一一对应,无需按顺序let &#123;b,a&#125; = &#123;a: 'hello', b: 'world'&#125;;console.log(b); // worldconsole.log(a); // hello 1234// 4. 剩余值let obj = &#123;name:'橘右京', age:20, gender:'男'&#125;;let &#123;name, ...a&#125; = obj;console.log(name, a); // name = zs a = &#123;age: 20, gender: \"男\"&#125;; 1234567891011// 5. 复杂情况,只要符合模式,即可解构let obj = &#123;name: '不知火舞',age: 22,dog: &#123; name: '娜可露露', age: 13 &#125;&#125;;let &#123;dog: &#123;name, age&#125;&#125; = obj;console.log(name, age); // 娜可露露 13 dog不会被赋值，只有最后的对象才会被赋值 1234567891011// 假设服务器上的获取的数据如下let res = &#123; data: ['a', 'b', 'c'], meta: &#123; code: 200, msg: '获取数据成功' &#125;&#125;// 如何获取到 code 和 msglet &#123; meta: &#123; code, msg &#125; &#125; = res;console.log(code, msg); // 200, 获取数据成功 函数 箭头函数（往下讲） 函数参数的默认值 123456789101112// ES5 中给参数设置默认值的变通做法function fn(x, y) &#123; y = y || 'world'; console.log(x, y);&#125;fn(1)// ES6 中给函数设置默认值function fn(x, y = 'world') &#123; console.log(x, y);&#125;fn(2)fn(2,3) rest参数 剩余参数,以…修饰最后一个参数,把多余的参数放到一个数组中 123456// 参数很多，不确定多少个，可以使用剩余参数function fn(...values) &#123; console.log(values); // [6, 1, 100, 9, 10]&#125;// 调用console.log(fn(6, 1, 100, 9, 10)); rest参数只能是最后一个参数 箭头函数 箭头函数的特点 箭头函数内部的this指向外部作用域中的this,箭头函数没有自己的this 箭头函数中内部没有arguments 箭头函数不能作为构造函数 12345let a = ()=&gt;&#123;&#125;// 等价于function a()&#123;&#125; 内置对象的扩展 array的扩展 扩展运算符(…可以把数组中的每一项展开) 12345// 合并两个数组let arr1 = [1, 2];let arr2 = [3, 4];let arr3 = [...arr1, ...arr2];console.log(arr3); // [1, 2, 3, 4] Array.from() 把伪数组转换成数组 伪数组必须有length属性,没有length得到一个空数组 转换后的数组长度根据伪数组的length决定的 12345678let fakeArr = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;let arr = Array.from(fakeArr);console.log(arr); // ['a', 'b', 'c']","categories":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/categories/es6/"},{"name":"js","slug":"es6/js","permalink":"http://yoursite.com/categories/es6/js/"}],"tags":[],"keywords":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/categories/es6/"},{"name":"js","slug":"es6/js","permalink":"http://yoursite.com/categories/es6/js/"}]},{"title":"原型链","slug":"js知识/原型链","date":"2019-10-28T00:30:01.000Z","updated":"2019-10-28T00:31:48.190Z","comments":true,"path":"2019/10/28/js知识/原型链/","link":"","permalink":"http://yoursite.com/2019/10/28/js知识/原型链/","excerpt":"","text":"","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"深拷贝和浅拷贝","slug":"js知识/深拷贝和浅拷贝","date":"2019-10-28T00:29:48.000Z","updated":"2019-10-28T06:10:29.422Z","comments":true,"path":"2019/10/28/js知识/深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2019/10/28/js知识/深拷贝和浅拷贝/","excerpt":"","text":"深拷贝和浅拷贝的区别 浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用” 为什么要使用深拷贝？我们希望在改变新的数组（对象）的时候，不改变原数组（对象） 深拷贝的要求程度我们在使用深拷贝的时候，一定要弄清楚我们对深拷贝的要求程度：是仅“深”拷贝第一层级的对象属性或数组元素，还是递归拷贝所有层级的对象属性和数组元素？ 怎么检验深拷贝成功改变任意一个新对象/数组中的属性/元素, 都不改变原对象/数组 拷贝类型1.基本数据类型的拷贝（名值存储栈内存中） number,string,boolean,null,undefined,symbol 2.引用（复杂）数据（名存栈内存，栈内存有指向堆内存的地址，值存对内存） 对象{a:1},数组[1,2,3],函数 对象：日期对象，正则对象…… 浅拷贝Object.assignES6中拷贝对象的方法，接受的第一个参数是拷贝的目标，剩下的参数是拷贝的源对象； 语法：Object.assign(target, …sources) Object.assign是一个浅拷贝，它只是在根属性(对象的第一层级)创建了一个新的对象，但是如果属性的值是对象的话，只会拷贝一份相同的内存地址。如下： 1234567891011121314var p = &#123; 'name': '张三', 'user':&#123; age:'16' &#125;&#125;;var copyP = &#123;&#125;;Object.assign(copyP, p);copyP.name = 'yang'console.log(copyP.name);//yangconsole.log(p.name);// 张三copyP.user.age = '19'console.log(copyP.user.age);//19console.log(p.user.age);//19 浅拷贝扩展运算符123456789101112var obj = &#123;'name': '撩课', 'college': ['H5','JAVA','Python']&#125;var obj2 = &#123;...obj&#125;;obj.name='小撩';//&#123;'name': '小撩', 'college': ['H5','JAVA','Python']&#125;console.log(obj);//&#123;'name': '撩课', 'college': ['H5','JAVA','Python']&#125;console.log(obj2); obj.college.push('Go');//&#123;'name': '小撩', 'college': ['H5','JAVA','Python','Go']&#125;console.log(obj); //&#123;'name': '小撩', 'college': ['H5','JAVA','Python','Go']&#125;console.log(obj2); 扩展运算符和Object.assign()存在同样的问题，对于值是对象的属性无法完全拷贝成两个不同对象； 但是如果属性都是基本类型的值的话，使用扩展运算符更加简洁。 深拷贝JSON.stringify注意： 拷贝的对象的值中如果有函数,undefined,symbol，经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失； 拷贝的数组的值中如果有函数,undefined,symbol，经过JSON.stringify()序列化后的JSON字符串中，这个值会变成null 无法拷贝不可枚举的属性，无法拷贝对象的原型链 拷贝Date引用类型会变成字符串 拷贝RegExp引用类型会变成空对象 对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null 123456789101112131415161718192021222324let obj = [ &#123; number1:null, number2:undefined, number3:function()&#123;return 1&#125;, number: 1, second: &#123; name: '333' &#125; &#125;, function()&#123;return 2&#125;, [3, 4], false, true, 45, null, undefined, &#123;data:new Date()&#125;, &#123;reg:/\\w/g&#125;, Number('sdgd34')]console.log(JSON.stringify(obj))// [&#123;\"number1\":null,\"number\":1,\"second\":&#123;\"name\":\"333\"&#125;&#125;,null,[3,4],false,true,45,null,null,&#123;\"data\":\"2019-10-28T05:47:23.064Z\"&#125;,&#123;\"reg\":&#123;&#125;&#125;,null] 手写简单的拷贝对象1234567891011121314151617181920212223242526272829303132333435/** * 辅助函数, 判定是否是对象 * @param obj * @returns &#123;boolean&#125; */function isObj(obj) &#123; return obj instanceof Object;&#125; /** * 深拷贝fromObj面的所有属性/值, 到toObj对象里面 * @param fromObj 拷贝对象 * @param toObj 目标对象 */function deepCopyObj2NewObj(fromObj, toObj) &#123; for (var key in fromObj) &#123; if(fromObj.hasOwnProperty(key))&#123; var fromValue = fromObj[key]; // 如果是值类型，那么就直接拷贝赋值 if (!isObj(fromValue)) &#123; toObj[key] = fromValue; &#125; else &#123; // 如果是引用类型，那么就再调用一次这个方法， // 去内部拷贝这个对象的所有属性 // fromValue是什么类型, 创建一个该类型的空对象 var tmpObj = new fromValue.constructor; // console.log(tmpObj); // debugger; deepCopyObj2NewObj(fromValue, tmpObj); toObj[key] = tmpObj; &#125; &#125; &#125;&#125; 存在大量深拷贝需求的代码——immutable提供的解决方案实际上，即使我们知道了如何在各种情况下进行深拷贝，我们也仍然面临一些问题： 深拷贝实际上是很消耗性能的。（我们可能只是希望改变新数组里的其中一个元素的时候不影响原数组，但却被迫要把整个原数组都拷贝一遍，这不是一种浪费吗？）所以，当你的项目里有大量深拷贝需求的时候，性能就可能形成了一个制约的瓶颈了。 immutable的作用： 通过immutable引入的一套API，实现： 在改变新的数组（对象）的时候，不改变原数组（对象） 在大量深拷贝操作中显著地减少性能消耗 12345const &#123; Map &#125; = require('immutable')const map1 = Map(&#123; a: 1, b: 2, c: 3 &#125;)const map2 = map1.set('b', 50)map1.get('b') // 2map2.get('b') // 50 总结1）在日常开发中一般并不需要拷贝很多特殊的引用类型，深拷贝对象使用JSON.stringify是最直接和简单的方法。 2）实现一个完整的深拷贝是非常复杂的,需要考虑到很多边界情况。对于特殊的引用类型有拷贝需求的话，建议借助第三方完整的库。","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"排序算法","slug":"算法/排序算法","date":"2019-10-25T07:45:22.000Z","updated":"2019-11-06T06:43:23.366Z","comments":true,"path":"2019/10/25/算法/排序算法/","link":"","permalink":"http://yoursite.com/2019/10/25/算法/排序算法/","excerpt":"","text":"八大算法 快速排序 冒泡排序 插入排序 堆排序 希尔排序 归并排序 简单选择排序 交换排序 快速排序原理：选择一个基准元素，将比基准元素小的元素放在其前面，比基准元素大的元素放在其后面，然后在将小于基准值元素的子数列和大于基准元素的子数列按原来的方法排序，直到整个序列有序; 时间复杂度：O(NlogN) 稳定性：不稳定 冒泡排序原理：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现他们的排序与排序要求相反时，就将他们互换。 时间复杂度：O(N*N) 稳定性：稳定 12345678910111213141516171819202122232425262728function bubbleSort(arr)&#123; let temp; for(let i = 0;i&lt;arr.length - 1;i++)&#123; for(let j = 0;j&lt;arr.length - 1 - i;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125; return arr&#125;function bubbleSort(arr)&#123; let temp,j; let len = arr.length while(len &gt; 0)&#123; for(j = 0;j&lt;len - 1;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; i--; &#125; return arr&#125; 插入排序原理：将一个记录插入到已排序好的有序表中，从而得到一个新的，记录数增1的有序表。即先将序列的第一个记录看成是一个有序的子序列，然后从第二个记录逐个进行插入，直至整个序列有序为止。 堆排序原理： 希尔排序原理： 归并排序原理： 堆排序原理： 选择排序原理： 第一趟：从第一个记录开始，将后面n-1个记录进行比较，找到其中最小的记录和第一个记录进行交换； 第二趟：从第二个记录开始，将后面n-2个记录进行比较，找到其中最小的记录和第2个记录进行交换； ……….. 第i趟：从第i个记录开始，将后面n-i个记录进行比较，找到其中最小的记录和第i个记录进行交换； 以此类推，经过n-1趟比较，将n-1个记录排到位，剩下一个最大记录直接排在最后； 时间复杂度：O(N*N) 稳定性：不稳定 1234567891011121314151617function selectSort(arr)&#123; let temp; for(let i = 0;i&lt;arr.length;i++)&#123; let minIndex = i; for(let j = i;j&lt;arr.length;j++)&#123; if(arr[j] &lt; arr[minIndex])&#123; minIndex = j &#125; &#125; if(minIndex !== i)&#123; temp = arr[i]; arr[i] = arr[minIndex] arr[minIndex] = temp &#125; &#125; return arr&#125; 交换排序原理：","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[],"keywords":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"基础知识的准备，高频面试点","slug":"面试/基础知识的准备，高频面试点","date":"2019-10-25T07:40:02.000Z","updated":"2019-10-25T07:43:43.268Z","comments":true,"path":"2019/10/25/面试/基础知识的准备，高频面试点/","link":"","permalink":"http://yoursite.com/2019/10/25/面试/基础知识的准备，高频面试点/","excerpt":"","text":"css盒子模型BFC，Flex局中Grid 变量类型JS 的数据类型分类和判断值类型和引用类型 原型与原型链原型和原型链定义继承 作用域和闭包执行上下文this闭包 性能问题有没有做过性能优化如何定位性能问题如何解决的 webpackloaderpluginTree Shaking代码分割打包优化技巧 PromisePromise 及其方法的实现 HTTP 1/2HTTP 有什么缺点HTTP2 有什么好处HTTPS 有什么好处， 有什么缺点，为什么。TCP, UDP 的区别， 最佳场景为什么说HTTPS 是安全的解释一下加密过程三次握手的过程，为什么握手三次, 为什么挥手四次 安全相关XSSCSRF 浏览器缓存策略缓存头相关浏览器 Cookie 相关 基础的数据结构和算法Tree,BFSDFS递归动态规划 框架相关1、React diff2、虚拟dom3、react 受控 非受控组件4、react 新旧生命周期5、 事件传播6、Event loop","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"常见面试题","slug":"面试/常见面试题","date":"2019-10-25T06:44:31.000Z","updated":"2019-10-28T00:29:25.443Z","comments":true,"path":"2019/10/25/面试/常见面试题/","link":"","permalink":"http://yoursite.com/2019/10/25/面试/常见面试题/","excerpt":"","text":"前端如何进行seo优化 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页，重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 一次性插入1000个div，如何优化插入的性能 使用Fragment，碎片收集 12var fragment = document.createDocumentFragment();fragment.appendChild(elem); 说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 12345678910// 为了解决第一个问题，Vue 提供了以下操作方法：// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)// 复制代码为了解决第二个问题，Vue 提供了以下操作方法：// Array.prototype.splicevm.items.splice(newLength) Vue 的父组件和子组件生命周期钩子函数执行顺序？ 加载渲染过程父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程父 beforeUpdate -&gt; 父 updated 销毁过程父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间；ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 父组件可以监听到子组件的生命周期吗？需要手动触发$emit 1234567&lt;!--// Parent.vue--&gt;&lt;Child @mounted=\"doSomething\"/&gt; &lt;!--// Child.vue--&gt;mounted() &#123; this.$emit(\"mounted\");&#125; 更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可， 1234567891011&lt;!--// Parent.vue--&gt;&lt;Child @hook:mounted=\"doSomething\" &gt;&lt;/Child&gt;doSomething() &#123; console.log('父组件监听到 mounted 钩子函数 ...');&#125;, &lt;!--// Child.vue--&gt;mounted()&#123; console.log('子组件触发 mounted 钩子函数 ...');&#125; 谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 组件中 data 为什么是一个函数？为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 虚拟 DOM 实现原理？虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；diff 算法 — 比较两棵虚拟 DOM 树的差异；pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 你有对 Vue 项目进行哪些优化？（1）代码层面的优化 v-if 和 v-show 区分使用场景computed 和 watch 区分使用场景v-for 遍历必须为 item 添加 key，且避免同时使用 v-if长列表性能优化事件的销毁图片资源懒加载路由懒加载第三方插件的按需引入优化无限列表性能服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩减少 ES6 转为 ES5 的冗余代码提取公共代码模板预编译提取组件的 CSS优化 SourceMap构建结果输出分析Vue 项目的编译优化 js的运行机制js是单线程，执行代码的时候，只有一个主线程来处理所有的任务。一个线程可以保证程序执行的一致性。 单线程的缺点就是当有一个任务阻塞的时候，就无法继续执行下去，为了解决这种问题，就出现了异步任务，异步任务就是执行这个任务时，无法立刻返回，驻现场就会把这个任务挂起，然后继续往下执行 js执行代码时会将不同变量存于内存中的不同位置，堆和栈，堆是对象，栈放基础类型变量以及对象的指针。 当我们调用js一个方法的时候，js会生成一个与这个方法对应的执行环境，又叫执行上下文，js是单线程，同一时间只能执行一个方法，于是这些方法就会放入一个栈中排队，这个栈叫做执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。这个过程也叫做event loop（事件循环） 事件队列：微任务和宏任务，执行顺序先微后宏 微任务 promise宏任务 setTimeout setIntervel js垃圾回收机制 有一组基本的固有可达值，由于显而易见的原因无法删除。例如: 本地函数的局部变量和参数 当前嵌套调用链上的其他函数的变量和参数 全局变量 还有一些其他的，内部的 这些值称为根。 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。 例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的， 可达性 和 引用链 不可达，引用链丢失，就回收对象。 null undefined NaN “” 的区别null 是一种特殊的object 空值，空指针，指针未指向任何内存空间（指向不存在的东西） 可以与undefined相等 == ，但 === 时不相等 可以等于自己，返回true 转化为数值是0，布尔值是false，字符串是’null’ 与false比较或严格比较，输出false undefined 对应类型undefined 全局作用域的一个变量 空值，未定义，使用了一个并未声明的变量时，或者使用了已经声明但还没有赋值的变量时，又或者使用了一个并不存在的对象属性时，返回这个值 可以等于自己，返回true 转为数值是NaN，布尔值是false，字符串是’undefined’ 与false比较或严格比较，输出false NaN 一种特殊的Number,表示非数字值，实际上也是一个数字（typeof NaN = “number”） NaN不等于自己(可以用isNaN()检测) 转为数值是NaN，布尔值是false，字符串是’NaN’ 与false比较或严格比较，输出false “” 字符串类型，不等于空格 空字符串，长度为0 转为数值是0，布尔值是false，字符串是”” 与false比较时输出true，严格比较时，输出false 完整的登陆流程登陆页面，点击登录按钮时触发的事件 客户端请求后台接口 后台验证通过，保存用户的登陆状态，并写入cookie中 用户进入需要登录权限的页面时，判断该状态，确认用户是否需要重新登录 如cookie过期，跳转至登录页重新认证 new操作符具体干了什么new的实现原理是什么？ 1let func = new Func() 创建一个空对象obj 1let obj = new Object() 链接到原型 让obj对象的proto指向构造函数Func的原型此时便建立了 obj 对象的原型链：obj-&gt;Func.prototype-&gt;Object.prototype-&gt;null 1obj.__proto__ = Func.prototype 绑定this值 让Func中的this指向obj对象 1Func.call(obj) 返回obj对象 1func = obj 数组去重方法 双重for循环 filter + indexOf 123arr.filter((item, index)=&gt; &#123; return arr.indexOf(item) === index&#125;) ES6 new Set() 123function distinct(arr) &#123; return Array.from(new Set([...arr]))&#125; for…of + Object 123456789101112function distinct(arr) &#123; let result = [] let obj = &#123;&#125; for (let i of arr) &#123; if (!obj[i]) &#123; result.push(i) obj[i] = 1 &#125; &#125; return result&#125; 回调函数与回调地狱在某一个方法的参数里放一个函数，这个函数就称之为回调函。 回调地狱，就是回调函数里又调用方法，方法的参数里又放函数。 回调地狱的根本问题： 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，影响后面的代码执行。 嵌套函数一多，就很难定位和处理错误。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"vue的数据双向绑定demo","slug":"vue/vue的数据双向绑定demo","date":"2019-10-25T00:59:48.000Z","updated":"2019-10-25T03:04:33.858Z","comments":true,"path":"2019/10/25/vue/vue的数据双向绑定demo/","link":"","permalink":"http://yoursite.com/2019/10/25/vue/vue的数据双向绑定demo/","excerpt":"","text":"目前的几种主流前端框架中，react是单向绑定，而angular.js和vue.js是双向绑定，实现双向绑定的方法有：1发布者-订阅者模式（backbone.js）2.脏值检查（angular.js）3.数据劫持（vue.js） 脏值检查：angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：1.DOM事件，譬如用户输入文本，点击按钮等。( ng-click )2.XHR响应事件（http）3.浏览器Location变更事件4.Timer事件 数据劫持： vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 所以，要实现mvvm的双向绑定，就必须实现以下几点：1.实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2.实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3.实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4.mvvm入口函数，整合以上三者 （一）实现Observer我们知道可以利用Obeject.defineProperty()来监听属性变动，那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。 （二）实现Compile Compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图， 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中。 （三）实现WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:1.在自身实例化时往属性订阅器(dep)里面添加自己2.自身必须有一个update()方法3.待属性变动dep.notify()通知时，能调用自身的update()方法，更新视图 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 （四）实现MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 （五）实现一个数据双向绑定demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" id=\"a\" v-model=\"text\"&gt; &#123;&#123;text&#125;&#125; &lt;/div&gt;&lt;script type=\"text/javascript\"&gt;// 模板解析function Compile (node, vm) &#123; if (node) &#123; this.$frag = this.nodeToFragment(node, vm) return this.$frag &#125;&#125;Compile.prototype = &#123; nodeToFragment: function (node, vm) &#123; var self = this var frag = document.createDocumentFragment() var child while (child = node.firstChild) &#123; self.compileElement (child, vm) frag.append(child) // 将所有子节点添加到fragment中 &#125; return frag &#125;, compileElement: function (node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ // 节点类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes // 解析属性 for (var i=0; i&lt;attr.length; i++) &#123; if (attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue // 获取v-model绑定的属性名 node.addEventListener('input', function (e) &#123; vm[name] = e.target.value &#125;) new Watcher(vm, node, name, 'value') &#125; &#125; &#125; // 节点类型为text if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1 // 与正则表达式匹配的第一个字符串 name = name.trim() new Watcher(vm, node, name, 'nodeValue') &#125; &#125; &#125;&#125;// 数据监听器function Observer (obj, vm) &#123; if (!obj || typeof(obj) !== 'object') return Object.keys(obj).forEach(function (key) &#123; defineReactive (vm, key, obj[key]) &#125;)&#125;function defineReactive (obj, key, val) &#123; var dep = new Dep() Observer(val) //监听子属性 Object.defineProperty(obj, key, &#123; get: function () &#123; if (Dep.target) &#123; dep.addSub(Dep.target) &#125; return val &#125;, set: function (newVal) &#123; if (val === newVal) return val = newVal //作为发布者发布通知，触发订阅者的更新函数 dep.notify() &#125; &#125;)&#125;// 消息订阅器，收集订阅者function Dep () &#123; this.subs = []&#125;Dep.prototype = &#123; addSub: function (sub) &#123; this.subs.push(sub) &#125;, notify: function () &#123; this.subs.forEach(function (sub) &#123; sub.update() &#125;) &#125;&#125;// 订阅者function Watcher (vm, node, name, type) &#123; Dep.target = this this.name = name this.node = node this.vm = vm this.type = type this.update() Dep.target = null&#125;Watcher.prototype = &#123; update: function () &#123; this.get() this.node[this.type] = this.value // 订阅者执行相应的操作 &#125;, // 获取data的属性值 get: function () &#123; this.value = this.vm[this.name] &#125;&#125;function Vue (options) &#123; this.data = options.data var data = this.data Observer(data, this) var id = options.el var dom = new Compile(document.querySelector(id), this) // 编译完成后，将dom返回到app中 document.querySelector(id).appendChild(dom)&#125;var vm = new Vue(&#123; el: '#app', data: &#123; text: 'hello world' &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}]},{"title":"关于vue的知识点","slug":"vue/关于vue的知识点","date":"2019-10-24T07:39:46.000Z","updated":"2019-10-25T08:16:46.957Z","comments":true,"path":"2019/10/24/vue/关于vue的知识点/","link":"","permalink":"http://yoursite.com/2019/10/24/vue/关于vue的知识点/","excerpt":"","text":"vue 是什么？构建页面，为页面提供驱动，关注视图层。 它包含什么，有哪些功能？ 生命周期 数据双向绑定 指令 style和class动态绑定 全局API 内置组件 组件通信 路由 状态管理 http请求工具axios 生命周期 beforeCreate 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不知道能在这个周期里面进行生命操作。 created（指定’el’选项，指定template选项，将template编译到render函数中） 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。在这个周期里面如果进行请求是可以改变数据并渲染，由于DOM未挂载，请求过多或者占用时间过长会导致页面线上空白。 beforeMount（创建 vm.$el） DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示双括号，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。 mounted（挂载完毕） 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。一般请求会放在这个地方，因为这边请求改变数据之后刚好能渲染。 beforeUpdate(虚拟DOM重新渲染并应用更新) 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。 updated 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。 beforeDestroy(解除绑定，销毁子组件，以及事件监听器) 这个周期是在组件销毁之前执行，有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作 destroyed(销毁完毕) 这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。 数据双向绑定实现数据双向绑定demo 指令 v-text 主要用来更新textContent，等于js的text属性 123&lt;!--两者等价--&gt;&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; v-html 它等同于JS的innerHtml属性，直接作为HTML进行渲染 v-pre v-pre主要用来跳过这个元素和它的子元素编译过程。可以用来显示原始的Mustache标签。跳过大量没有指令的节点加快编译。 v-cloak 这个指令是用来保持在元素上直到关联实例结束时进行编译。 v-once v-once关联的实例，只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视为静态内容跳过，这可以用于优化更新性能。 v-if | v-else | v-else-if v-if可以实现条件渲染 v-else是搭配v-if使用的，它必须紧跟在v-if或者v-else-if后面，否则不起作用。 v-else-if充当v-if的else-if块，可以链式的使用多次。可以更加方便的实现switch语句。 v-show 也是用于根据条件展示元素。和v-if不同的是，如果v-if的值是false，则这个元素被销毁，不在dom中。但是v-show的元素会始终被渲染并保存在dom中，它只是简单的切换css的dispaly属性。 v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 v-for 用v-for指令根据遍历数组来进行渲染有下面两种遍历形式 12&lt;div v-for=\"(item,index) in items\"&gt;&lt;/div&gt; //使用in，index是一个可选参数，表示当前项的索引&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; //使用of 下面是一个例子，并且在v-for中，拥有对父作用域属性的完全访问权限。 1234567891011121314151617&lt;ul id=\"app\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123;parent&#125;&#125;-&#123;&#123;item.text&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; var example = new Vue(&#123; el:'#app', data:&#123; parent:'父作用域' items:[ &#123;text:'文本1'&#125;, &#123;text:'文本2'&#125; ] &#125; &#125;)&lt;/script&gt; 会被渲染为： 1234&lt;ul id=\"app\"&gt; &lt;li&gt;父作用域-文本1&lt;/li&gt; &lt;li&gt;父作用域-文本2&lt;/li&gt;&lt;/ul&gt; 注意：当v-for和v-if同处于一个节点时，v-for的优先级比v-if更高。这意味着v-if将运行在每个v-for循环中 key的作用 vue的dom渲染是虚拟dom，数据发生变化时，diff算法会只比较更改的部分，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。举例说明：有一个列表我们现在在中间插入了一个元素，diff算法会默认复用之前的列表并在最后追加一个，如果列表存在选中一类的状态则会随着复用出现绑定错误的情况而不是跟着原元素，key的作用就可以给他一个标识，让状态跟着数据渲染。（这一块是我自己的一个大概理解，表述不太清楚，具体的可以去查一下文档，本文就不具体描述此问题了。） v-bind v-bind用来动态的绑定一个或者多个特性。没有参数时，可以绑定到一个包含键值对的对象。常用于动态绑定class和style。以及href等。简写为一个冒号【 ：】 v-model 这个指令用于在表单上创建双向数据绑定。v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它选择Vue实例数据做为具体的值。 v-model修饰符 &lt;1&gt; .lazy 默认情况下，v-model同步输入框的值和数据。可以通过这个修饰符，转变为在change事件再同步。 1&lt;input v-model.lazy=\"msg\"&gt; &lt;2&gt; .number自动将用户的输入值转化为数值类型 &lt;3&gt; .trim自动过滤用户输入的首尾空格 v-on v-on主要用来监听dom事件，以便执行一些代码块。表达式可以是一个方法名。简写为：【 @ 】 事件修饰符 .stop 阻止事件继续传播 .prevent 事件不再重载页面 .capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 .self 只当在 event.target 是当前元素自身时触发处理函数 .once 事件将只会触发一次 .passive 告诉浏览器你不想阻止事件的默认行为 123456789101112131415161718192021222324252627&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用v-on:click.prevent.self会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 属性-computed,watch….. computed getter和setter 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; watch 监听对象 123456watch: &#123; &apos;obj.question&apos;: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125;&#125; 深度监听 12345678910watch: &#123; obj: &#123; handler: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125;, deep: true, immediate: true &#125;&#125; immediate的作用：当值第一次进行绑定的时候并不会触发watch监听，使用immediate则可以在最初绑定的时候执行。 style和class动态绑定Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false&#125; 数组语法： 123456&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125; 数组语法： 12345678910&lt;div v-bind:style=\"[styleColor, styleSize]\"&gt;&lt;/div&gt;data: &#123; styleColor: &#123; color: 'red' &#125;, styleSize:&#123; fontSize:'23px' &#125;&#125; 全局API $nextTick 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。 $set 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 内置组件 component 有两个属性:is|inline-template 渲染一个‘元组件’为动态组件，按照’is’特性的值来渲染成那个组件 transition 为组件的载入和切换提供动画效果，具有非常强的可定制性 transition-group 作为多个元素/组件的过渡效果 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们 slot 作为组件模板之中的内容分发插槽，slot元素自身将被替换 组件通信 props 1.父子组件通信2.单向数据流3.以数组的形式接受参数4.或以对象的方式接受参数，可以约定接受数据的类型。5.子组件想修改时，只能通过$emit派发自定义事件，父组件收到后进行修改。 ref 与 $parent / $children 1.适用 父子组件通信2.ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例3.$parent / $children：访问父 / 子实例 provide / inject 适用于 隔代组件通信 vuex 1.父子组件/非父子组件/隔代/兄弟 Bus 1.父子组件/非父子组件/隔代/兄弟2.eventBus的原理是引入一个新的vue实例，然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。 123456789import Vue from 'vue'; export default new Vue(); // import eventBus from 'eventBus.js'; // 接收eventBus .$on('getTarget', this.getTarget); // 触发 eventBus.$emit(\"getTarget\", 22); 路由vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？ （1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null, null, path);window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 状态管理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 插槽http请求工具axios","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}]},{"title":"在做项目中，曾经遇到过的难题","slug":"错点总结/在做项目中，曾经遇到过的难题","date":"2019-10-24T01:04:06.000Z","updated":"2019-11-06T06:02:10.230Z","comments":true,"path":"2019/10/24/错点总结/在做项目中，曾经遇到过的难题/","link":"","permalink":"http://yoursite.com/2019/10/24/错点总结/在做项目中，曾经遇到过的难题/","excerpt":"","text":"elementui 和 chrome兼容问题：饿了么框架的el-select标签选择国码，在iphone移动端的chrome78中，需要点击两次才能切换成功，安卓没有这个问题。测试参数如下：iphone xr w/ ios 13.1.3chrome 78.0.3904.67 in Dark mode 解决1：使用原生的select标签。在ios+chrome无法显示select的options数据，安卓没有这个问题，解决方案无效。 解决2：使用弹窗+raido标签。 webpack4打包，按需加载js问题：webpack4打包的时候，会把一个.vue页面中的js全部打包进一个文件中，导致进入此页面时，加载很慢，页面很长时间无法响应。 解决：webpack4按需加载。 移动端|pc端适配问题：iphone点击输入框，有焦点时，屏幕会放大。 12解决：&lt;meta name=&quot;viewport&quot; content=&apos;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0, user-scalable=0&apos;&gt; 问题：打包的时候，static静态文件资源路径问题 解决：引入staticc文件时，前面不加’/‘ 记住密码问题：浏览器会自动记住登录名，当用户没有用浏览器记住用户名时，系统没有自动记住登录名。 解决：使用浏览器记住时，会自动填充，判断该input是否有值，无值则使用系统的已记住的用户列表1.使用localStorage存储用户名2.自定义下拉列表，点击选项后填入表单 图片上传/转换问题：裁剪压缩，用到canvas，canvas转换过的图片是base64,再转换为blob,最后转为File类型传给后台，但IE11及以下不兼容File的构造函数。 解决：提示IE浏览器不支持裁剪，或者后台可接收blob的文件。","categories":[{"name":"错题总结","slug":"错题总结","permalink":"http://yoursite.com/categories/错题总结/"}],"tags":[],"keywords":[{"name":"错题总结","slug":"错题总结","permalink":"http://yoursite.com/categories/错题总结/"}]},{"title":"那些面试过程中，HR会问的面试题","slug":"面试/interviewQuestion","date":"2019-10-16T00:53:34.859Z","updated":"2019-10-24T01:01:54.635Z","comments":true,"path":"2019/10/16/面试/interviewQuestion/","link":"","permalink":"http://yoursite.com/2019/10/16/面试/interviewQuestion/","excerpt":"","text":"HR会问的面试题 自我介绍 姓名、离职原因、工作经历，未来规划、职业兴趣、控制在一分半内。您好，我叫xx，来自xx，xx年毕业，今天来是想面试贵公司的前端岗位,从毕业至今，一直在深圳发展，在xxx公司从事前端岗位，我个人对前端有很大的兴趣，看到自己写的东西，会有成就感，在未来的几年，我也会专注提升自己前端方面的技术，不断地充实学习，能给自己一个更好的成绩通过渠道XX关注到贵公司前端岗位的招聘信息，该职位跟我的职业相对契符合，非常渴望能够进入贵公司发展，我有信心，也有决心做好这份工作。以上是我的自我介绍，谢谢。 为什么想回长沙？ 长沙在IT发展方面的环境和氛围可能和深圳那些大城市比，有一点点的不足，但长沙也是一个非常有发展潜力的城市，在前端岗位方面，它也是有需求的。而且相对于大城市来说，长沙会很轻松一些，我觉得，我很适合待在长沙。 为什么去了深圳？ 深圳是个适合年轻人，挺有活力也有竞争力的城市，在深圳，能感受到一种向上拼搏的动力，而且，深圳的互联网发展技术很成熟也很普及，在深圳能学到很有有用的东西，很符合我目前的职业发展。 为什么离职？ 在这家公司待了两年，有经历有成长，但这家公司做的项目大都类似，很难会有技术上的一个突破，也很难去学习掌握一门新技术，我希望我能去新的地方，学到更多的东西 为什么选择我家公司？ 因为贵公司…………（挑求职信息说） 做过H5、小程序吗？ 小程序目前为止，还没有接触过，h5有接触过有做过，H5就是在手机端展示的页面，我觉得做H5和小程序还有做web网页，所运用的技术其实相差不大，只是呈现给用户的方式不同。 你觉得你在工作中的优缺点是什么？ 缺点就是太优点是：我觉得自己的领悟能力还ok，比如需求描述一两遍，我就大概知道需要做一个什么样的东西我逻辑分析能力很强，写代码的时候只要清楚的理解逻辑就能抓住重点，大概自己心里有个底，写代码就很容易。我对前端的知识掌握的还可以，js，css用的很熟练，对当前流行的框架和打包技术有一定的理解。我对接受新的技术，学习新的技术，有很大的兴趣，偶尔自己有空，就喜欢去钻研。 你过来我们公司，你的优势是什么？ 工作经验，对前端基础知识掌握扎实， 日后有什么打算？你未来一到三年的一个职业规划是什么？ 3-5年职业规划，能独当一面 你都是怎么去学习和关注新技术的？ 思否，掘金，csdn，github, 你近几年工作中有哪些心得或总结？ 我们的项目大部分是团队合作，就目前的XX项目，我们的团队分配有前端后台运维UI测试，有一套完整的开发流程，目前这个项目是个二期项目，所以刚进入团队，我的主要职责就是优化页面和维护前期功能，同时合并两个系统，整理代码，整理文档结构，在后续期间，又开发了余额/积分几个需求模块。但这个项目对我影响比较大，它有内网和外网两个系统，但两个系统之间，差异特别小，所以老板希望可以合并为一个，而且这个项目经过了很多人的手，它代码的页面、变量、函数、组件、接口都写的很混乱，重复、冗余，没有一个很明确的结构模式，为了方便后续维护，就必须需要去归纳整理，我刚开始接手，也有一些压力，需要去分析代码合并的一些差异性，需要去整理项目文件结构，而且项目页面多，稍不注意就很容易出错，虽然过程很难，但最后还是很完美的完成了这个任务，收获挺多，也让我认识到，代码规范的重要性。 你有那些你觉得你写的不错的代码块，分享一下。 有些过开源项目吗？ 写过 npm 包吗，写过 webpack 插件吗？ 看过哪些框架或者类库的源码，有什么收获？ 对自己的评价？ 有上进心、团队精神、坚持、主动学习、注重细节 您重新选择工作，会看重哪些？ 成长空间、培训机会，薪酬，工作环境。 您之前的薪资？ 保密，不便透露 您的期望薪资？ 您之前公司做的是什么项目？用过什么框架？ 您有什么需要问的吗？ 对目前应聘的岗位有何期待？比如到岗时间？是不是很紧缺？为什么职位是空着的？ 这个职位最重要的职责是什么？您心目中对这个岗位的理想人选有什么要求？目前贵公司招前端，是开发新项目还是跟进当前项目？ 目前项目使用的什么框架？使用了哪些技术？ 从招聘信息上看，贵公司更似乎偏向有经验的人，那么对于没经验或者经验很少的人会作什么考虑？ 贵公司目前是怎样的一个发展情况？近些年有什么计划？比如研发方面，有没有开发新项目的需求？ 目前贵公司的工作地点？是否有分公司？贵公司的年度业绩？ 贵公司目前在这个岗位是什么样的晋升渠道？贵公司会有给员工学习的平台或者培训机会吗？ 贵公司的试用期限？试用期限的薪资？ 贵公司的上下班制度？是否有加班？最晚会加班到几点？ 贵公司对这个岗位的薪资需求？ 贵公司会有哪些福利待遇？有多少假期？是否有年终奖？年终的时候是否会总结员工个人的业绩？这个岗位的业绩是通过什么来总结的呢？","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"流莹离的第一篇博文","slug":"first/first","date":"2019-10-15T07:51:16.000Z","updated":"2019-10-15T08:22:12.338Z","comments":false,"path":"2019/10/15/first/first/","link":"","permalink":"http://yoursite.com/2019/10/15/first/first/","excerpt":"","text":"哈哈啦啦如果这就是爱！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]},{"title":"Hello World","slug":"first/hello-world","date":"2019-10-15T01:11:41.129Z","updated":"2019-10-15T01:11:41.129Z","comments":true,"path":"2019/10/15/first/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/15/first/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}